name: "tmp: Latency Failure Simulation"

on:
  workflow_dispatch:
  push:
    paths:
      - ".github/trigger-latency-sim.txt"

permissions:
  contents: write
  id-token: write

env:
  AWS_REGION: us-west-2
  HUB_CLUSTER: argocd-usw2
  SPOKE_CLUSTER: opsera-usw2-np

jobs:
  inject-and-deploy:
    name: "ðŸ’‰ Inject Latency & Deploy"
    runs-on: ubuntu-latest
    outputs:
      bad_tag: ${{ steps.build.outputs.tag }}
      
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GH_PAT || secrets.GITHUB_TOKEN }}

      - name: Inject Latency into Vote App
        run: |
          echo "## ðŸ’‰ Injecting 2 Second Latency" >> $GITHUB_STEP_SUMMARY
          echo "This will cause the canary to fail and rollback." >> $GITHUB_STEP_SUMMARY
          
          # Use Python to generate the file to avoid heredoc issues
          python3 << 'EOF'
          code = '''from flask import Flask, render_template, request, make_response, g
          from redis import Redis
          import os
          import socket
          import random
          import json
          import logging
          import time

          LATENCY_SECONDS = 2.0

          option_a = os.getenv('OPTION_A', "Cats")
          option_b = os.getenv('OPTION_B', "Dogs")
          hostname = socket.gethostname()

          app = Flask(__name__)

          gunicorn_error_logger = logging.getLogger('gunicorn.error')
          app.logger.handlers.extend(gunicorn_error_logger.handlers)
          app.logger.setLevel(logging.INFO)

          def get_redis():
              if not hasattr(g, 'redis'):
                  g.redis = Redis(host="redis", db=0, socket_timeout=5)
              return g.redis

          @app.route("/", methods=['POST','GET'])
          def hello():
              app.logger.warning(f"INJECTED LATENCY: Sleeping for {LATENCY_SECONDS}s")
              time.sleep(LATENCY_SECONDS)
              
              voter_id = request.cookies.get('voter_id')
              if not voter_id:
                  voter_id = hex(random.getrandbits(64))[2:-1]

              vote = None

              if request.method == 'POST':
                  redis = get_redis()
                  vote = request.form['vote']
                  app.logger.info('Received vote for %s', vote)
                  data = json.dumps({'voter_id': voter_id, 'vote': vote})
                  redis.rpush('votes', data)

              resp = make_response(render_template(
                  'index.html',
                  option_a=option_a,
                  option_b=option_b,
                  hostname=hostname,
                  vote=vote,
              ))
              resp.set_cookie('voter_id', voter_id)
              return resp

          @app.route("/health")
          def health():
              time.sleep(1.0)
              return "OK"

          if __name__ == "__main__":
              app.run(host='0.0.0.0', port=80, debug=True, threaded=True)
          '''
          import textwrap
          with open('vote/app.py', 'w') as f:
              f.write(textwrap.dedent(code))
          EOF
          
          sed -i 's/Version: v[0-9]*/Version: v99-SLOW/g' vote/templates/index.html 2>/dev/null || true
          
      - name: Configure AWS
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Build & Push Bad Image
        id: build
        run: |
          TAG="bad-slow-$(date +%Y%m%d%H%M%S)"
          echo "tag=$TAG" >> $GITHUB_OUTPUT
          
          aws ecr get-login-password --region ${{ env.AWS_REGION }} | \
            docker login --username AWS --password-stdin 792373136340.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com
          
          cd vote
          docker build -t 792373136340.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/vote:$TAG .
          docker push 792373136340.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/vote:$TAG
          
          echo "## Built bad image: $TAG" >> $GITHUB_STEP_SUMMARY

      - name: Update QA & Sync
        run: |
          BAD_TAG="${{ steps.build.outputs.tag }}"
          sed -i "s|newTag: .*|newTag: $BAD_TAG|g" .opsera-voting-app/k8s/overlays/qa/kustomization.yaml
          
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add .
          git commit -m "Deploy slow canary: $BAD_TAG"
          git push
          
          aws eks update-kubeconfig --name ${{ env.HUB_CLUSTER }} --region ${{ env.AWS_REGION }}
          kubectl patch application voting-app-qa -n argocd --type merge -p '{"metadata":{"annotations":{"argocd.argoproj.io/refresh":"hard"}}}'
          sleep 10
          
          aws eks update-kubeconfig --name ${{ env.SPOKE_CLUSTER }} --region ${{ env.AWS_REGION }}
          curl -sLO https://github.com/argoproj/argo-rollouts/releases/latest/download/kubectl-argo-rollouts-linux-amd64
          chmod +x kubectl-argo-rollouts-linux-amd64
          ./kubectl-argo-rollouts-linux-amd64 restart vote-rollout -n voting-app-qa || true

  watch-rollback:
    name: "ðŸ‘€ Watch Rollback"
    needs: inject-and-deploy
    runs-on: ubuntu-latest
    
    steps:
      - name: Configure AWS
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Watch Canary
        run: |
          curl -sLO "https://dl.k8s.io/release/v1.28.0/bin/linux/amd64/kubectl"
          chmod +x kubectl && sudo mv kubectl /usr/local/bin/
          curl -sLO https://github.com/argoproj/argo-rollouts/releases/latest/download/kubectl-argo-rollouts-linux-amd64
          chmod +x kubectl-argo-rollouts-linux-amd64
          sudo mv kubectl-argo-rollouts-linux-amd64 /usr/local/bin/kubectl-argo-rollouts
          aws eks update-kubeconfig --name ${{ env.SPOKE_CLUSTER }} --region ${{ env.AWS_REGION }}
          
          echo "# Canary Failure Demo" >> $GITHUB_STEP_SUMMARY
          echo "Bad Image: ${{ needs.inject-and-deploy.outputs.bad_tag }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          ROLLBACK=false
          for i in $(seq 1 30); do
            PHASE=$(kubectl get rollout vote-rollout -n voting-app-qa -o jsonpath='{.status.phase}' 2>/dev/null || echo "Unknown")
            echo "Check $i: $PHASE" >> $GITHUB_STEP_SUMMARY
            
            if [ "$PHASE" = "Degraded" ]; then
              echo "CANARY FAILED - Rollback triggered!" >> $GITHUB_STEP_SUMMARY
              ROLLBACK=true
            fi
            
            if [ "$PHASE" = "Healthy" ] && [ "$ROLLBACK" = true ]; then
              echo "ROLLBACK COMPLETE!" >> $GITHUB_STEP_SUMMARY
              break
            fi
            sleep 20
          done
          
          echo "" >> $GITHUB_STEP_SUMMARY
          kubectl-argo-rollouts get rollout vote-rollout -n voting-app-qa 2>&1 >> $GITHUB_STEP_SUMMARY || true

  restore:
    name: "ðŸ”§ Restore"
    needs: watch-rollback
    if: always()
    runs-on: ubuntu-latest
    
    steps:
      - uses: actions/checkout@v4
        with:
          token: ${{ secrets.GH_PAT || secrets.GITHUB_TOKEN }}
          ref: main
          
      - run: |
          git pull origin main
          python3 << 'EOF'
          code = '''from flask import Flask, render_template, request, make_response, g
          from redis import Redis
          import os
          import socket
          import random
          import json
          import logging

          option_a = os.getenv('OPTION_A', "Cats")
          option_b = os.getenv('OPTION_B', "Dogs")
          hostname = socket.gethostname()

          app = Flask(__name__)

          gunicorn_error_logger = logging.getLogger('gunicorn.error')
          app.logger.handlers.extend(gunicorn_error_logger.handlers)
          app.logger.setLevel(logging.INFO)

          def get_redis():
              if not hasattr(g, 'redis'):
                  g.redis = Redis(host="redis", db=0, socket_timeout=5)
              return g.redis

          @app.route("/", methods=['POST','GET'])
          def hello():
              voter_id = request.cookies.get('voter_id')
              if not voter_id:
                  voter_id = hex(random.getrandbits(64))[2:-1]

              vote = None

              if request.method == 'POST':
                  redis = get_redis()
                  vote = request.form['vote']
                  app.logger.info('Received vote for %s', vote)
                  data = json.dumps({'voter_id': voter_id, 'vote': vote})
                  redis.rpush('votes', data)

              resp = make_response(render_template(
                  'index.html',
                  option_a=option_a,
                  option_b=option_b,
                  hostname=hostname,
                  vote=vote,
              ))
              resp.set_cookie('voter_id', voter_id)
              return resp

          @app.route("/health")
          def health():
              return "OK"

          if __name__ == "__main__":
              app.run(host='0.0.0.0', port=80, debug=True, threaded=True)
          '''
          import textwrap
          with open('vote/app.py', 'w') as f:
              f.write(textwrap.dedent(code))
          EOF
          
          sed -i 's/Version: v99-SLOW/Version: v14/g' vote/templates/index.html 2>/dev/null || true
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add .
          git diff --staged --quiet || git commit -m "Restore after simulation"
          git push || true
